syntax = "proto3";
package lobbies;
option go_package = "lobbies/proto";
option csharp_namespace = "Battlegrounds.Proto.Lobbies";

// This proto file defines the gRPC service and messages for managing game lobbies, including hosting, joining, updating lobby state, sending chat messages, leaving the lobby, launching the game, reporting game status, and changing the map. 
// The service allows for real-time updates to be broadcasted to all participants in the lobby whenever a relevant event occurs.
service LobbyService {

    // Allows a participant to host a new lobby, which will trigger updates to other participants about the new lobby and its initial state.
    rpc HostLobby(HostLobbyRequest) returns (stream LobbyStateUpdate);

    // Allows a participant to join an existing lobby, which will trigger updates to other participants in the lobby about the new participant and their assigned slot.
    rpc JoinLobby(JoinLobbyRequest) returns (stream LobbyStateUpdate);

    // Allows the host or participants to update the lobby state, which will be broadcasted to all other participants in the lobby. This can include changes to team compositions, lobby settings, or other relevant information.
    rpc UpdateLobbyState(LobbyStateUpdate) returns (Empty);

    // Allows participants to send chat messages within the lobby, which will be broadcasted to all other participants in the lobby.
    rpc SendChatMessage(ChatMessage) returns (Empty);

    // Allows a participant to leave the lobby, which will trigger updates to other participants and free up their slot for others to join.
    rpc LeaveLobby(LeaveLobbyRequest) returns (Empty);

    // Initiates the launching of the game for all lobby participants.
    rpc LaunchGame(LaunchGameRequest) returns (Empty);

    // Reports the end-of-match status back to the lobby, which can be used for post-game processing and analytics
    rpc ReportGameStatus(ReportGameStatusRequest) returns (Empty);

    // Changes the map for the lobby    
    rpc ChangeMap(ChangeMapRequest) returns (ChangeMapResponse);

    // Initiates a download sequence for all participants in the lobby and streams progress updates
    rpc InitiateDownload(InitiateDownloadRequest) returns (stream DownloadState);

    // Reports download progress from a participant
    rpc ReportDownloadProgress(ReportDownloadProgressRequest) returns (Empty);

}

// TODO: Replace participantId with a token to better prove the identity of the participant in requests

message JoinLobbyRequest {
    string lobby_id = 1;
    string participant_id = 2;
    string password = 3; // Optional
}

message LeaveLobbyRequest {
    string lobby_id = 1;
    string participant_id = 2;
}

message HostLobbyRequest {
    string host_id = 1;
    string lobby_name = 2;
    optional string password = 3;
    map<string, string> settings = 4;
    string game_id = 5;
}

message LaunchGameRequest {
    string lobby_id = 1;
    string participant_id = 2;
}

message ReportGameStatusRequest {
    string lobby_id = 1;
    string participant_id = 2;
    string status = 3; // e.g., "started", "finished", "error"
}

message LobbyStateUpdate {
    string lobby_id = 1;
    string participant_id = 2;
    string event_type = 3;
    oneof change {
        SlotUpdate slot_update = 4;
        LobbySetting settings_update = 5;
        Team team_update = 6; // Note, this will ignore the "Slot" field since there's a separate message for slots
        ChatMessage chat_message = 7;
        Lobby lobby_state = 8;
        Participant participant_update = 9;
        Empty empty = 10; // For cases where no specific change is made
        SystemMessage system_message = 11; // For system-wide notifications or errors
        DownloadState download_state = 12; // For download progress updates
    }
}

message SlotUpdate {
    int32 team_id = 1;
    Slot slot = 2; // Updated slot information
}

message Lobby {
    string id = 1;
    string name = 2;
    string host_id = 3;
    repeated Team teams = 5;
    repeated Participant participants = 6;
    map<string, string> settings = 7; // Key-value pairs for lobby settings
    string game_id = 8;
}

message LobbySetting {
    string key = 1;
    string old_value = 2; // Optional, can be empty if not applicable
    string new_value = 3;
}

message Team {
    int32 id = 1;
    string alias = 2;
    string type = 3;
    repeated Slot slots = 4;
}

message Slot {
    int32 id = 1;
    optional string participant_id = 2;
    string faction = 3;
    optional string company_id = 4;
    optional string ai_difficulty = 5;
    bool hidden = 6;
    bool locked = 7;
}

message Participant {
    string participant_id = 1;
    string name = 2;
    bool is_ai = 3;
    bool ready = 4;
}

message ChatMessage {
    string lobby_id = 1;
    string sender_id = 2;
    string channel = 3;
    string content = 4;
}

message SystemMessage {
  string message_type = 1; // e.g., "info", "warning", "error"
  string content = 2;
}

message PlayMap {
    string map_id = 1;
    int32 max_players = 2;
}

message ChangeMapRequest {
    string lobby_id = 1;
    string participant_id = 2;
    PlayMap new_map = 3;
}

message ChangeMapResponse {
    bool success = 1;
    int32 error_reason = 2; // 0 for no error, other values can represent specific errors (e.g., 1 for map not found, 2 for insufficient permissions)
}

message InitiateDownloadRequest {
    string lobby_id = 1;
    string participant_id = 2; // Must be the host
    string resource_id = 3; // Identifier for the resource to download (e.g., map ID, mod ID)
}

message ReportDownloadProgressRequest {
    string lobby_id = 1;
    string participant_id = 2;
    float progress = 3; // Progress percentage (0.0 to 100.0)
    bool completed = 4; // Whether the download is complete
}

message DownloadStatus {
    string participant_id = 1;
    float progress = 2; // Progress percentage (0.0 to 100.0)
    bool completed = 3; // Whether the participant has completed the download
}

message DownloadState {
    string resource_id = 1;
    repeated DownloadStatus participant_status = 2; // Status for each participant
    bool all_completed = 3; // Whether all participants have completed the download
}

message Empty {}
